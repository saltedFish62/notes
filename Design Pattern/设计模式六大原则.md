# 设计模式的六大原则

​	**设计模式遵循的六大原则：**

1. 单一职责原则 - Single Responsibility Principle
2. 开闭原则 - Open Closed Principle
3. 里氏替换原则 - Liskov Substitution Principle
4. 接口隔离原则 - Interface Segregation Principle
5. 依赖倒置原则 - Dependence Inversion Principle
6. 迪米特原则 - Law of Demeter

​    事实上，六大原则的前五个原则是面向对象的 **SOLID原则**。

## 单一职责原则

### 定义：

​	任何一个软件模块都应该只对一类行为者负责。

### 背景：

​	历史上，曾经这样描述单一职责原则：任何一个软件模块都应该有且仅有一个被修改的原因。

​	在现实环境中，软件系统为了满足用户和所有者的要求，总是会面临这样那样的修改。而系统用户或者所有者就是该设计原则中所指的‘被修改的原因’。

​	所以也可以这样描述单一职责原则：任何一个软件模块都应该只对一个用户或者系统相关者负责。

​	这里的‘用户’和‘系统相关者’在用词上也不完全准确，它们很有可能指的是一个或多个用户和利益相关者，只要这些人希望对系统进行的变更相似的，就可以归为一类或者称其为行为者。

​	所以，SRP的最终描述变成了：任何一个软件模块都应该只对一类行为者负责。

​	这个软件模块可以指一个源代码文件，或者是一组紧密相关的函数和数据结构。

### 示例：

​	有如下产品类：

![image-20190801222841992](http://ww2.sinaimg.cn/large/006tNc79gy1g5kjqubc4zj30xu0r6my4.jpg)

​	该类中有三个方法：

```js
getPrice()      // 获取价格
getOrderList()  // 获取订单列表
getReturnList() // 获取退货列表
```

​	消费者需要 `getPrice()` 函数，库房管理员需要 `getOrderList()` 函数，售后人员需要 `getReturnList()` 函数。

​	该类同时服务三类用户，并且可能因为订单函数的修改而影响到售后。所以这个类违背了 **单一职责原则**。

​	为了解决这个问题，就对类进行拆分，使每个类只服务一种用户：

![image-20190801223259653](http://ww4.sinaimg.cn/large/006tNc79gy1g5kjvbqbgwj30wu0o43zh.jpg)

- 商品类 服务 消费者
- 订单类 服务 库房管理员
- 售后类 服务 售后人员

​    之后需要再修改其中某类时，都不会再牵扯到其他类，而且每个类只服务一种用户，单一职责原则极大的降低了代码的耦合。

## 开闭原则

### 定义：

​	设计良好的软件应该易于扩展，同时抗拒修改。

​	简单的说就是系统应该不需要修改的前提下就可以轻易扩展。这个原则是软件设计，系统架构中非常重要的原则。

### 背景：

​	一般情况，我们接到需求变更的通知，通常方式可能就是修改模块的源代码，然而修改已经存在的源代码是存在很大风险的，尤其是项目上线运行一段时间后，开发人员发生变化，这种风险可能就更大。所以，为了避免这种风险，在面对需求变更时，我们一般不修改源代码，即所谓的对修改关闭。

### 示例：

​	现在有这样的业务：需要将数据在不同的平台展示。结构如下图：

![image-20190802200110814](http://ww3.sinaimg.cn/large/006tNc79gy1g5ll3p5yagj30x60kewez.jpg)

​	这将PC和APP的数据展示放到同一个类里，如果这时候要加一种在PAD上的展示方式，就要修改展示代码，否则无法加入新的功能。

​	接下来按照OCP原则来优化：

![image-20190802203042353](http://ww3.sinaimg.cn/large/006tNc79gy1g5llycwsq0j30rq0ig772.jpg)

​	抽象一个数据运算层，也可以说是MVC中的Model层，该层主要生成格式化数据，给前端的展示层提供标准化数据，在这个结构中添加PAD展示类，就不需要修改原有的代码，增加PAD的展示类即可。再添加其他的展示类都可以不需要修改原有的代码，这样设计就易于扩展同时抗拒修改。同时底层的数据发生变化时，只需要修改数据运算层，无需修改前端展示类，这样也解除了依赖，做到依赖翻转。

## 里氏替换原则

### 定义：

- `派生类（子类）`对象可以在程式中代替其`基类（超类）`对象。

- 如果对每一个类型为 `T1`的对象 `o1`，都有类型为 `T2` 的对象`o2`，使得以` T1`定义的所有程序 `P` 在所有的对象 `o1` 都代换成 `o2` 时，程序 `P` 的行为没有发生变化，那么类型 `T2` 是类型 `T1` 的子类型。

### 背景：

​	比如，假设有两个类，一个是Base类，另一个是Child类，并且Child类是Base的子类。那么一个方法如果可以接受一个基类对象b的话:method1(Base b)那么它必然可以接受一个子类的对象method1(Child c).

​	里氏替换原则是继承复用的基石。只有当衍生类可以替换掉基类，软件单位的功能不会受到影响时，基类才能真正的被复用，而衍生类也才能够在基类的基础上增加新的行为。

### 示例：

​	有矩形和正方形，正方形是一种特殊的矩形，即它是长和宽相等的矩形。于是设计类时，很容易将矩形设计成正方形的父类：

​	![image-20190802205153554](http://ww3.sinaimg.cn/large/006tNc79gy1g5lmke68roj30v00gswfo.jpg)

​	其实这样是不符合里氏替换原则的。当用户调用矩形类时：

```js
矩形 r = new 矩形()
r.setH = 10
r.setW = 2
assert(r.area() == 20)
```

​	然后将 `矩形类` 换成 `正方形类` 时，用户调用就会出现问题，也就是矩形出现的地方，不能替换成子类 `正方形` 。这样就违背了里氏替换原则。

​	复合里氏替换原则的设计如下：

![image-20190802205539842](http://ww4.sinaimg.cn/large/006tNc79gy1g5lmocwsahj30vu0bk74o.jpg)

​	在警察检查身份证号，每个中国人出生就有一个身份证号，所以这里中国人的子类,工人或者司机都存在这个获取身份证号的方法，任何父类出现的地方子类都可以替换，这就是里氏替换原则。

## 接口隔离原则

### 定义：

​	客户（client）应该不依赖于它不使用的方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。

### 背景：

​	一个接口的职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”。专门的接口指什么？就是指提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。

### 示例：

![image-20190802211522783](http://ww3.sinaimg.cn/large/006tNc79gy1g5ln8vvfhgj30v00ewmyj.jpg)

```js
User1() 调用 op1()
User3() 调用 op2()
User3() 调用 op3()
```

​	由上图可知，虽然 `User1` 并不调用 `op2()` 和 `op3()` ，但形成了依赖关系。此时 `OPS` 对于 `User1` 来说就太冗余了，并且对于 `op2` 和  `op3` 的修改可能会对 `User1` 产生影响，用接口隔离可以解决这个问题。

![image-20190802212933262](http://ww4.sinaimg.cn/large/006tNc79gy1g5lnnkknupj30uc0m4ju1.jpg)

​	这样 `User1` 就依赖 `U1Ops` 和 `op1`。于是无论对其他的怎么改，影响到 `User1` 的概率都不大了。

​	另外这个原理在软件架构上也有意义：

![image-20190802213445063](http://ww2.sinaimg.cn/large/006tNc79gy1g5lnsyzlz5j30sq05u3z6.jpg)

​	系统S引入了框架F，框架F必须使用数据库D。那么就形成了S依赖于F，F依赖于D的关系。

​	此时D中包含了F中的不需要的功能，那么这些功能也是S中不需要的。而我对D的修改会导致F可能会重新部署，接着又会导致S的重新部署。更可怕是D中的一个无关功能修改的错误，导致F和S都无法运行。

​	任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦

## 依赖反转原则

### 定义：

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象；

- 抽象不应该依赖细节；

- 细节应该依赖抽象。

> 每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是**低层模块**，原子逻辑的再组装就是**高层模块**。在Java语言中，**抽象**就是指接口或抽象类，两者都是不能直接被实例化的；**细节**就是实现类，实现接口或继承抽象类而产生的类就是**细节**，其特点就是可以直接被实例化，也就是可以加上一个关键字new产生一个对象。

### 背景：

​	依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，这也是正常人的思维方式，我要开奔驰车就依赖奔驰车，我要使用笔记本电脑就直接依赖笔记本电脑，而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据系统设计的需要产生了抽象间的依赖，代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生的。

​	采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。

​	如果想要在软件设计上追求稳定，就必须使用稳定的抽象接口，少依赖多变的具体实现，可以参考以下具体原则：

- 应该在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。
- 不要在具体实现类上创建衍生类
- 不要覆盖包含具体实现的函数
- 避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事务名称。

### 示例：

​	有司机驾驶奔驰车的类图：

![image-20190803144143158](http://ww1.sinaimg.cn/large/006tNc79gy1g5mhhjnomrj30uo0eegmo.jpg)

```java
class Driver
{
    public function drive(BMW $bmw)
    {
        $bmw->run();
    }
}

class BMW
{
    public function run()
    {
        echo "宝马上路......";
    }
}

class Client{
    public function goToWork(){
        $driver = new Driver();
        $bmw = new BMW();
        $driver->drive($bmw);
    }
}
```

​	这样设计的意思，就是开着宝马去上班，但如果买了奔驰，想开奔驰去上班的话，就要修改Driver类，使代码的耦合度很高。并且这只是要增加一辆奔驰车，就要修改已实现的代码而不是增加代码，这样就违反了开闭原则。

​	按照依赖反转原则设计：

![image-20190803145537556](http://ww1.sinaimg.cn/large/006tNc79gy1g5mhw1lg2zj30w00e6769.jpg)

​	抽象是对实现的约束，是对依赖者的一种约束，不仅仅约束自己，还同时约束自己与外部的关系，其目的就是保证所有的细节不脱离契约的范畴，确保约束双方按照规定好的契约（抽象）共同发展，只要抽象这条规范还在，细节就不能脱离这个规范。

## 迪米特原则

### 定义：

​	也称为最少知识原则（Least Knowledge Principle，LKP），一个对象应该对其他对象有最少的了解。即一个类应该对自己需要耦合或调用的类知道得最少，被耦合或调用的类内部是如何复杂都和该类没关系，类只需要知道被耦合或调用的类提供的这么多public方法，其他的一概不关心。

### 背景：

​	迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。

​	迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。

### 示例：

​	超市有这样的类图，消费者可以拿钱包，钱包可以拿钱出来和放钱进去，柜台小弟负责结账。

![image-20190803172018278](http://ww1.sinaimg.cn/large/006tNc79gy1g5mm2jck70j30eq0do752.jpg)

​	柜台小弟如果要结账，那么 `pay()` 就需要这样实现：

```js
pay(payment) {
  Customer c;
  if (c.getWallet().getTotal() >= payment) {
    c.getWallet().reduceMoney(payment)
  } else {
    // do something when dont have enough money
  }
}
```

​	这样意味着柜台小弟可以拿着客户的钱包，看钱包里的钱够不够，再帮客户拿钱出来结账。这明显是有问题的，事实上拿钱包等动作都是客户该做的事情，与柜台小弟无关，柜台小弟并不需要知道顾客是不是拿钱包还是直接从口袋里掏钱出来。

​	将各角色的行为改成如下：

![image-20190803173409799](http://ww4.sinaimg.cn/large/006tNc79gy1g5mmgyjumyj30cq0c474z.jpg)

​	这样柜台小弟只需要接受顾客的付款行为，他不需要知道顾客的钱包的情况，这样符合最少知道的原则。

