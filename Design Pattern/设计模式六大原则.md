# 设计模式的六大原则

​	**设计模式遵循的六大原则：**

1. 单一职责原则 - Single Responsibility Principle
2. 开闭原则 - Open Closed Principle
3. 里氏替换原则 - Liskov Substitution Principle
4. 接口隔离原则 - Interface Segregation Principle
5. 依赖倒置原则 - Dependence Inversion Principle
6. 迪米特原则 - Law of Demeter

​    事实上，六大原则的前五个原则是面向对象的 **SOLID原则**。

## 单一职责原则

### 定义：

​	任何一个软件模块都应该只对一类行为者负责。

### 背景：

​	历史上，曾经这样描述单一职责原则：任何一个软件模块都应该有且仅有一个被修改的原因。

​	在现实环境中，软件系统为了满足用户和所有者的要求，总是会面临这样那样的修改。而系统用户或者所有者就是该设计原则中所指的‘被修改的原因’。

​	所以也可以这样描述单一职责原则：任何一个软件模块都应该只对一个用户或者系统相关者负责。

​	这里的‘用户’和‘系统相关者’在用词上也不完全准确，它们很有可能指的是一个或多个用户和利益相关者，只要这些人希望对系统进行的变更相似的，就可以归为一类或者称其为行为者。

​	所以，SRP的最终描述变成了：任何一个软件模块都应该只对一类行为者负责。

​	这个软件模块可以指一个源代码文件，或者是一组紧密相关的函数和数据结构。

### 示例：

​	有如下产品类：

![image-20190801222841992](http://ww2.sinaimg.cn/large/006tNc79gy1g5kjqubc4zj30xu0r6my4.jpg)

​	该类中有三个方法：

```js
getPrice()      // 获取价格
getOrderList()  // 获取订单列表
getReturnList() // 获取退货列表
```

​	消费者需要 `getPrice()` 函数，库房管理员需要 `getOrderList()` 函数，售后人员需要 `getReturnList()` 函数。

​	该类同时服务三类用户，并且可能因为订单函数的修改而影响到售后。所以这个类违背了 **单一职责原则**。

​	为了解决这个问题，就对类进行拆分，使每个类只服务一种用户：

![image-20190801223259653](http://ww4.sinaimg.cn/large/006tNc79gy1g5kjvbqbgwj30wu0o43zh.jpg)

- 商品类 服务 消费者
- 订单类 服务 库房管理员
- 售后类 服务 售后人员

​    之后需要再修改其中某类时，都不会再牵扯到其他类，而且每个类只服务一种用户，单一职责原则极大的降低了代码的耦合。

## 开闭原则

### 定义：

​	设计良好的软件应该易于扩展，同时抗拒修改。

​	简单的说就是系统应该不需要修改的前提下就可以轻易扩展。这个原则是软件设计，系统架构中非常重要的原则。

### 背景：

​	一般情况，我们接到需求变更的通知，通常方式可能就是修改模块的源代码，然而修改已经存在的源代码是存在很大风险的，尤其是项目上线运行一段时间后，开发人员发生变化，这种风险可能就更大。所以，为了避免这种风险，在面对需求变更时，我们一般不修改源代码，即所谓的对修改关闭。

### 实例：

​	现在有这样的业务：需要将数据在不同的平台展示。结构如下图：

![image-20190802200110814](http://ww3.sinaimg.cn/large/006tNc79gy1g5ll3p5yagj30x60kewez.jpg)

​	这将PC和APP的数据展示放到同一个类里，如果这时候要加一种在PAD上的展示方式，就要修改展示代码，否则无法加入新的功能。