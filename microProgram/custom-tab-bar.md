# 自定义 tabbar

## 原生的自定义tabbar

​	微信小程序提供了原生的tabbar支持，需要在app.json配置相应的内容。具体可以参考文档。但原生的tabbar样式比较单一，所幸小程序也提供了自定义tabbar的接口。具体办法就是在app.json的tabbar字段里添加： custom: true。然后在根目录下创建文件夹 **custom-tab-bar**，然后在该文件夹中以组件的形式实现自定义的tabbar。

​	当然有很多种方式可以实现tabbar，可以直接写一个组件，然后将组件样式层级定高，也就是 _z-index_ 属性值设置大一点。但考虑到微信小程序提供了原生的自定义tabbar接口，那就尝试一下。

​	原生的tabbar接口本质上也还是一个组件，只是这个组件中推荐使用 **\<cover-view\>** ，而不是 **\<view\>** 。接下来又有问题：**\<cover-view\>** 中只能嵌套 **\<cover-view\>** 和 **\<cover-image\>**，这也是原生自定义组件的限制。但用**\<cover-view\>**的方式则可以避免了渲染层级的问题，因为**\<cover-view\>**在小程序里默认是较高层级的，所以会在**\<view\>**之上。

​	接下来又是一个问题：在跳转tab页的时候，如果目标tab页还没有被渲染，则会渲染目标页，因为小程序的自定义tabbar本质上是一个组件，所以自定义tabbar会被重新渲染，保存的**current**状态（也就是当前tab的状态）也会丢失，导致当前tab的显示出现问题。

​	小程序官方demo给的解决办法是在page生命周期函数onShow中手动更新current状态。因为每次跳转都会丢失状态，所以就在跳转完之后手动更新tabbar的状态。为此小程序给了一个api：getTabBar()。具体的更新状态的代码如下：

```js
getTabBar().setData( { current: key } )
//	其中的 key 为该页面对应的 current 值。
```

​	然而在这样实现完成之后，发现自定义tabbar的fixd定位的效果并不好。也就是说当页面向下滑动的时候，自定义tabbar会跟随页面滑动，并且时常无法固定回底部。这个体验就很不好了。

​	那么换上文提到的另一个思路来做。

## 组件形式的自定义tabbar

​	要以组件形式来实现自定义tabbar，其中关键点就是层级和定位。要保证组件的层级是最高的，也就是在页面中不会别其他的组件覆盖而导致看不到或者被遮挡。定位则是要保证组件的行为是一直固定在屏幕下方的。

​	这两个关键点都用css解决：

```css
.container {
  position: fixed;
  bottom: 0;
  z-index: 999; // or higher
}
```

​	那么问题又来了：以组件形式的自定义tabbar怎么进行tab页跳转呢？

​	由于tab页中有两个页面包含有长列表，也就是不断的下滑动作会不断的增长列表，所以数据会比较大，而且页面的状态需要缓存，比如购物车，当我选择了几件商品，然后想看看还有没有想要的，切到其他tab页看看，再切回购物车，状态丢失就要重新再选商品，那购物体验就不舒服了。因此不适合做成单页的应用，单页的应用通常不会保存其他页的状态。当然也可以仅保存当前的页面的数据和页数，然后在需要加载上一个页面或下一个页面时再取页面来将已保存的页面替代，但这样的成本太高了。那么有什么办法能既保存状态，有能良好的跳转呢？

​	注意到小程序提供了一个将原生tabbar隐藏的接口：

```js
wx.hideTabBar()
```

​	以原生tabbar的方式，声明tab页，并且制作原生的tabbar。在小程序的app.js中将tabbar隐藏，然后在每一个tab页中引入组件形式的自定义tabbar。

​	同样也会遇到当前页状态保存的问题。当然也可以沿用上述小程序官方demo的办法：在每个tab页中手动的更新状态。

​	我的办法是将current状态保存到应用的全局数据中，即 `getApp().globalData.current`。

​	这里还有一个知识点，就是在小程序中，组件本质上是page的超集，page有的生命周期，component同样也会有。因此组件有一个pageLifetimes的属性，对应page的生命周期。然后就可以利用component的onShow钩子，将每次在page中更新current的操作移到component中来，这个代价就是增加一个全局数据，这一点可以自己衡量，增加全局数据确实是一个不太友好的行为，但这样可以让page页面减少一种行为。

​	那么绕这一圈的意义在于：使用原生tabbar声明的tab页可以被小程序缓存，也就是当用户切到其他页面的时候购物车页面不会被销毁，页面所有的数据也不会丢失。而同时也可以使用自定义的tabbar。